<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Heart Shake Physics</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0b10;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
    }
    #wrap {
      position: relative;
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
    }
    canvas {
      width: min(92vw, 520px);
      height: min(92vw, 520px);
      touch-action: none;
    }
    .hud {
      position: absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
    }
    .hud > * { pointer-events: auto; }

    button {
      background: #ffffff10;
      border: 1px solid #ffffff22;
      color: #fff;
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 600;
      backdrop-filter: blur(8px);
    }
    button:active { transform: scale(0.98); }

    .badge {
      background: #ffffff10;
      border: 1px solid #ffffff22;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      opacity: 0.95;
      backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div class="hud">
      <button id="enable">Enable motion</button>
      <div class="badge" id="status">tilt: — | particles: 0</div>
    </div>
    <canvas id="c"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const enableBtn = document.getElementById('enable');

  // --- HiDPI
  function resize() {
    const cssSize = Math.min(window.innerWidth * 0.92, 520);
    canvas.style.width = cssSize + 'px';
    canvas.style.height = cssSize + 'px';
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // --- Heart SDF in normalized coords
  // We map canvas coords -> p in [-1,1] range, centered.
  // Heart implicit (classic): (x^2 + y^2 - 1)^3 - x^2 y^3 = 0
  // We'll tweak scale for nicer shape.
  function heartF(p) {
    // p: {x,y} ~ [-1..1]
    const x = p.x;
    const y = p.y * 1.05; // slight stretch
    const a = x*x + y*y - 1;
    return a*a*a - x*x * y*y*y;
  }

  // Approx signed distance via f / |grad f| (good enough for collisions)
  function heartSDF(p) {
    const eps = 1e-3;
    const f = heartF(p);
    const fx = (heartF({x: p.x + eps, y: p.y}) - heartF({x: p.x - eps, y: p.y})) / (2*eps);
    const fy = (heartF({x: p.x, y: p.y + eps}) - heartF({x: p.x, y: p.y - eps})) / (2*eps);
    const g = Math.hypot(fx, fy) || 1e-6;
    return f / g; // ~signed distance
  }

  function heartNormal(p) {
    const eps = 1e-3;
    const d0 = heartSDF(p);
    const dx = (heartSDF({x: p.x + eps, y: p.y}) - d0) / eps;
    const dy = (heartSDF({x: p.x, y: p.y + eps}) - d0) / eps;
    const l = Math.hypot(dx, dy) || 1e-6;
    return { x: dx / l, y: dy / l };
  }

  // --- World mapping
  function toWorld(px, py) {
    const w = canvas.width, h = canvas.height;
    const s = Math.min(w, h) * 0.46;     // radius-ish
    const cx = w * 0.5, cy = h * 0.52;   // little lower center
    return { x: (px - cx) / s, y: (py - cy) / s };
  }
  function toCanvas(p) {
    const w = canvas.width, h = canvas.height;
    const s = Math.min(w, h) * 0.46;
    const cx = w * 0.5, cy = h * 0.52;
    return { x: cx + p.x * s, y: cy + p.y * s };
  }

  // --- Particles
  const particles = [];
  function spawn(n = 18) {
    for (let i = 0; i < n; i++) {
      // spawn near top inside heart
      let p = { x: (Math.random()*2 - 1) * 0.20, y: -0.35 + Math.random()*0.08 };
      // Ensure inside by nudging if needed
      for (let k = 0; k < 20; k++) {
        const d = heartSDF(p);
        if (d <= 0) break; // inside
        const nrm = heartNormal(p);
        p.x -= nrm.x * d;
        p.y -= nrm.y * d;
      }

      const size = 9 + Math.random()*10;
      particles.push({
        p,
        v: { x: (Math.random()*2 - 1) * 0.2, y: Math.random()*0.05 },
        r: (size / 520) * 0.25, // world radius-ish
        s: size,                // pixel size for drawing
        rot: Math.random() * Math.PI * 2,
        w: (Math.random()*2 - 1) * 4,
        life: 1
      });
    }
    // cap
    const MAX = 900; // можна 600..1200 залежно від телефону
while (particles.length > MAX) particles.shift();
  }

  // --- Tilt -> gravity (world units)
  // We'll interpret beta (front-back) and gamma (left-right).
  let gravity = { x: 0, y: 0.9 };
  let tiltText = '—';

  function onOrientation(e) {
    const beta = e.beta ?? 0;   // x axis tilt: [-180..180]
    const gamma = e.gamma ?? 0; // y axis tilt: [-90..90]

    // Normalize to [-1..1]
    const gx = Math.max(-1, Math.min(1, gamma / 45));
    const gy = Math.max(-1, Math.min(1, beta / 45));

    // Convert to gravity; flip y so "down" is positive y in our world
    gravity.x = gx * 1.2;
    gravity.y = (gy * 1.2) + 0.2; // slight baseline pull

    tiltText = `β:${beta.toFixed(0)} γ:${gamma.toFixed(0)}`;
  }

  // --- Shake detection via devicemotion (acceleration magnitude)
let lastShake = 0;
let shakeEnergy = 0;
let spawnBurstUntil = 0;

let lastMag = 0;
let motionSeen = false;

function isNum(v) { return typeof v === 'number' && Number.isFinite(v); }

function onMotion(e) {
  motionSeen = true;

  // 1) Спроба: прискорення (acceleration або includingGravity)
  const a =
    (e.acceleration && isNum(e.acceleration.x)) ? e.acceleration :
    (e.accelerationIncludingGravity && isNum(e.accelerationIncludingGravity.x)) ? e.accelerationIncludingGravity :
    null;

  if (a && (isNum(a.x) || isNum(a.y) || isNum(a.z))) {
    const ax = isNum(a.x) ? a.x : 0;
    const ay = isNum(a.y) ? a.y : 0;
    const az = isNum(a.z) ? a.z : 0;

    const mag = Math.hypot(ax, ay, az);
    lastMag = mag;

    // baseline різний для acceleration vs includingGravity
    const usingPureAccel = (e.acceleration && isNum(e.acceleration.x));
    const baseline = usingPureAccel ? 1.2 : 11.5;
    const excess = Math.max(0, mag - baseline);

    shakeEnergy += excess;
  } else if (e.rotationRate && (isNum(e.rotationRate.alpha) || isNum(e.rotationRate.beta) || isNum(e.rotationRate.gamma))) {
    // 2) Якщо accel нема — детектимо по гіроскопу (rotationRate)
    const ra = isNum(e.rotationRate.alpha) ? e.rotationRate.alpha : 0;
    const rb = isNum(e.rotationRate.beta) ? e.rotationRate.beta : 0;
    const rg = isNum(e.rotationRate.gamma) ? e.rotationRate.gamma : 0;

    const rmag = Math.hypot(ra, rb, rg); // град/сек
    lastMag = rmag;

    // Поріг для гіроскопа: підкручуй 80..160
    const excess = Math.max(0, rmag - 90);
    shakeEnergy += excess * 0.04; // масштабуємо, щоб було схоже на accel
  } else {
    // 3) Нема нічого — залишимо lastMag як 0
    lastMag = 0;
  }

  const now = performance.now();
  if (shakeEnergy > 6 && (now - lastShake) > 120) {
    lastShake = now;
    shakeEnergy = Math.max(0, shakeEnergy - 5);
    spawnBurstUntil = now + 700;
    spawn(12);
  }
}

  // --- Permission handler (iOS needs it)
  async function enableSensors() {
    try {
      // iOS 13+ permission gates
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== 'granted') throw new Error('Motion permission denied');
      }
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res2 = await DeviceOrientationEvent.requestPermission();
        if (res2 !== 'granted') throw new Error('Orientation permission denied');
      }

      window.addEventListener('deviceorientation', onOrientation, { passive: true });
      window.addEventListener('devicemotion', onMotion, { passive: true });
      setTimeout(() => {
  if (!motionSeen) {
    alert('devicemotion не приходить. Відкрий сторінку по HTTPS у Safari/Chrome (не в Telegram/Instagram webview) і перевір доступ Motion & Orientation у налаштуваннях.');
  }
}, 1500);
      enableBtn.textContent = 'Motion enabled ✓';
      enableBtn.disabled = true;

      // small welcome burst
      spawn(40);
    } catch (err) {
      enableBtn.textContent = 'Enable failed';
      console.warn(err);
      alert('Не вдалось отримати доступ до сенсорів. Спробуй Safari/Chrome на телефоні та дозволь Motion/Orientation.');
    }
  }
  enableBtn.addEventListener('click', enableSensors);

  // Desktop fallback: mouse tilt imitation
  let mouseTilt = null;
  window.addEventListener('mousemove', (e) => {
    if (enableBtn.disabled) return;
    const nx = (e.clientX / window.innerWidth) * 2 - 1;
    const ny = (e.clientY / window.innerHeight) * 2 - 1;
    mouseTilt = { x: nx, y: ny };
    gravity.x = nx * 1.0;
    gravity.y = ny * 1.0 + 0.2;
    tiltText = `mouse`;
  }, { passive: true });

  // Tap to spawn on desktop
  canvas.addEventListener('pointerdown', () => spawn(20));

  // --- Physics step
const params = {
  damp: 0.992,
  bounce: 0.35,
  friction: 0.22,
  substeps: 2
};

function step(dt) {
  // Потік сердечок після шейку
  const tnow = performance.now();
  if (tnow < spawnBurstUntil) {
    const rate = 90; // сердечок/сек
    const count = Math.max(1, Math.floor(rate * dt));
    spawn(count);
  }

  const steps = params.substeps;
  const h = dt / steps;

  for (let s = 0; s < steps; s++) {
    for (const b of particles) {
      // integrate
      b.v.x += gravity.x * h;
      b.v.y += gravity.y * h;

      b.v.x *= params.damp;
      b.v.y *= params.damp;

      b.p.x += b.v.x * h;
      b.p.y += b.v.y * h;

      b.rot += b.w * h * 0.35;

      // collide with heart boundary (keep inside: SDF <= -radius)
      const d = heartSDF(b.p);
      const target = -b.r;
      if (d > target) {
        const n = heartNormal(b.p);

        // push back inside
        const push = (d - target);
        b.p.x -= n.x * push;
        b.p.y -= n.y * push;

        // reflect velocity along normal
        const vn = b.v.x * n.x + b.v.y * n.y; // normal component
        const vtX = b.v.x - vn * n.x;         // tangential
        const vtY = b.v.y - vn * n.y;

        // bounce on normal, friction on tangential
        const newVn = -vn * params.bounce;
        b.v.x = vtX * (1 - params.friction) + newVn * n.x;
        b.v.y = vtY * (1 - params.friction) + newVn * n.y;
      }
    }
  }
}

  // --- Draw
  function drawHeartMask() {
    // Draw heart path and use clip
    ctx.save();
    ctx.beginPath();

    // Parametric heart for nice outline
    const w = canvas.width, h = canvas.height;
    const s = Math.min(w, h) * 0.46;
    const cx = w * 0.5, cy = h * 0.52;

    // Build path
    const N = 260;
    for (let i = 0; i <= N; i++) {
      const t = (i / N) * Math.PI * 2;
      // classic param heart
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
      // normalize
      const px = cx + (x / 18) * s;
      const py = cy - (y / 18) * s;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();

    // background fill
    ctx.fillStyle = '#1a0f18';
    ctx.fill();

    // subtle border
    ctx.strokeStyle = '#ff4d8a55';
    ctx.lineWidth = Math.max(2, canvas.width * 0.006);
    ctx.stroke();

    // clip for particles
    ctx.clip();
  }

  function drawParticle(p) {
    const c = toCanvas(p.p);
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(p.rot);

    // little heart with text glyph for simplicity
    ctx.font = `${p.s}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // glow
    ctx.shadowBlur = p.s * 0.55;
    ctx.shadowColor = '#ff4d8a';

    ctx.fillText('❤', 0, 0);
    ctx.restore();
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    step(dt);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Heart + clip
    drawHeartMask();

    // particles
    for (const p of particles) drawParticle(p);

    ctx.restore(); // from drawHeartMask save()

    statusEl.textContent =
  `tilt: ${tiltText} | particles: ${particles.length} | motion: ${motionSeen ? lastMag.toFixed(1) : 'no'}`;

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>